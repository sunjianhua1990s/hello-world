信息的表示和处理
=============

###C语言中移位操作
1. 对于无符号整数，>>均为逻辑右移；对于有符号整数，>>大多说编译器解释为算术右移。
2. 加法的优先级比移位要高，所以1<<2+3<<4，得到结果时(1<<(2+3))<<4。

###整数表示
>char 1B -2^7 ~ 2^7

>short 2B    -2^15 ~ 2^15-1

>int 4B  2^-31 ~ 2^31

>long 32bit   4B -2^31 ~ 2^31

>long 64bit   8B -2^63 ~ 2^63

>long long 8B -2^63 ~2^63
gcc编译器中使用**-std=c99**使用long long

###补码
1. 原码的最高有效位为符号位，用来确定剩下的为应该取正还是负；0有正负之分[0000][1000]
2. 反码的最高有效位的权为-(2^(w-1) -1)；0有两种[0000][1111]。
3. 补码的最高有效位的权为-2^(w-1)；最小值为[1000]最大值为[0111]；

###C语言高频漏洞
1. 有符号到无符号数的隐身转换；memcpy(void * dest, void * src, size_t n)；中size_t为unsigned int型。

###整数运算
1. 整数相加溢出检查

```C
	int tadd_ok(int x, int y)
    {
        int sum = x + y;
        int neg_over = x < 0 && y < 0 && sum > = 0;
        int pos_over = x >= 0 && y >= 0 && sum < 0;
        return !neg_over && !pos_over;
    }

```    
2. 整数相乘溢出检测

```C
    int tmult_ok(int x, int y)
    {
        int p = x*y;
        return !x || p/x==y;
    }
```

证明过程：

1. 我们知道想x*y可以写成 一个2w位的补码数字。用u表示低w位的无符号数，v表示高w位的补码数字。那么x\y=v*2^u


