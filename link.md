链接
=====

#程序编译过程
1. 预处理器cpp 阶段：将.c 文件预处理成.i 文件，处理包括头文件插入，宏定义等
2. 编译器ccl 阶段：将.i 文件翻译成.s 文件，即翻译成汇编语言
3. 汇编器as 阶段：将.s 翻译成机器语言.o ，把这些指定打包为一种叫做可重定位目标程序，
4. 链接器ld 阶段：将.o 文件链接合并成可执行目标程序.out。

```C
gcc -O2 -g -o p main.c swap.c
cpp main.c /tmp/main.i
ccl /tmp/main.i main.c -O2 -o /tmp/main.s
as -o /tmp/main.o /tmp/main.s
ld -o p /tmp/main.o /tmp/swap.o
unix>
```

#链接
1. 在编译时由静态编译器完成
2. 在加载和运行时由动态连接器完成

#目标文件
1. 可重定位目标文件，包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来
2. 可执行目标文件，包含二进制代码和数据，其形式可以直接拷贝到存储器并运行
3. 共享目标文件，一种特殊的可重定位目标文件，可以在加载或运行时被动态的加载到存储器并链接

##可重定位目标文件

| ELF头 |
|-------|
| .text |
| .rodata |
| .data |
| .bss|
| .symtab |
| .rel.text |
| .rel.data |
| . debug |
| .line |
| .strtab |
| 节头部表 |

1. ELF头，以1个16字节的序列开始，描述了生成该文件的系统的字的大小和字节顺序；
2. `.text`：已编译程序的机器代码
3. `.rodata`：只读数据，如`printf`语句中的格式串和开关语句的跳转表
4. `.data`：已初始化的全局C变量，局部变量运行时保存在栈中，不出现在可重定位目标文件中
5. `.bss`：未初始化的全局C变量，不占实际空间，仅占一个占位符
6. `.symtab`：一个符号表，存放程序中定义和引用的函数，和全局变量信息
7. `.rel.text`：一个`.text`节中位置的列表，当链接器把这个目标文件和其他文件结合时，需要修改这些位置
8. `.rel.data`：被模块引用或定义的任何全局变量的重定位信息
9. `.debug`：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，原始的C源文件。 `-g`参数才能得到
10. `.line`：原始C程序中的行号和`.text`节中机器指令之间的映射。`-g`参数才能得到
11. `.strtab`：一个字符串表，其内容包括`.symtab`和`.debug`节中的符号表，异界节头部中的节名字。

#静态链接
链接器完成两个主要任务：
1. 符号解析：将每个符号引用，刚好和一个符号定义联系起来。
2. 重定位：链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得他们指向这个存储器位置，从未重定位这些节。

##符号解析
1. 对于那些和引用定义在相同模块中的本地符号的引用，编译器只允许每个本地符号只有一个一个定义，还要确保静态本地变量，他们也会有本地链接器符号，拥有唯一的名字。
2. 对于全局符号的引用解析，当遇到一个不再当前模块中定义的符号时，它会假设该符号是在其他模块中定义的，生成一个链接器符号表条目`.symtab`，把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用的符号，她就会输出一跳错误信息并终止。
3. C\++ 和Java 中链接器符号的毁坏。重载的实现：
 C\++和Java 能使用重载，是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器唯一的名字，这种编码过程叫毁坏，反过程叫恢复。
 一个被毁坏的类名字是由名字中符号的整数数量，后面跟原始名字组成，如类Foo被编码成3Foo ，方法被编码为原始方法名，后面加上`_ _`,加上被毁坏的类名，再加上，每个参数的单个字母编码。比如`Foo::bar(int, long)`来被编码成`bar_ _3Fooil`。
4. 对于多重定义，规定函数和已初始化的全局变量时强符号，未初始化的全局变量时弱符号。Unix 链接器规定，不允许多个强符号，如果有一个强符号和多个弱符号，选择强符号，如果没有强符号，弱符号中任意选择一个。

###与静态库链接
1. 将目标模块打包成一个单独文件，静态库，它可以作为链接器的输入。当链接器构造一个输出可执行文件时，它只拷贝静态库里被应用程序引用的目标模块。
2. 链接器如何使用静态库来解析引用？ 顺序不能放错。

##重定位
重定位由两步组成：
1. 重定位节和符号的定义，首先将所有相同类型的节合并成同一类型的新的聚合节，然后链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节和符号。
2. 重定位节中的符号引用，修改代码节和数据节中每个符号的引用，使他们指向正确的运行地址。

##可执行目标文件

| ELF头部 |
|---------|
| 段头部表 |
| .init |
| .text |
| .rodata |
| .data |
| .bss|
| .symtab |
| . debug |
| .line |
| .strtab |
| 节头部表 |

`.init`:节定义了一个小函数，叫做`_init`，程序的初始化代码会调用它。

##加载可执行文件
Linux 运行时存储器映像：
只读段`.init, .texr, .rodata`
读写段`.data, .bss`
运行时堆，由`malloc`创建
共享库的存储器映射区域
用户栈，运行时创建
内核虚拟存储器，对用户不可见

**过程：**
1. 当外壳程序运行一个程序时，父外壳程序生成一个子进程，子进程通过`execve`系统调用启动加载器。
2. 加载器删除子进程现有的虚拟存储器段，并创建新的代码、数据、堆、栈段，新的堆栈段初始化为0.
3. 通过虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段会被初始化可执行文件内容。
4. 最后加载器跳转到`_start`地址，它最终会调用应用程序的`main`函数。除了一些头部信息，在加载过程中没有任何从磁盘到存储器的数据拷贝。直到CPU引用了一个被映射的虚拟页采进行拷贝，此时，操作系统利用它的页面调度机制自动将页面从磁盘传给存储器。

##动态链接共享库
在运行时，可以加载到任意的存储器地址，并和一个在存储器只能够的程序链接起来。
```C
unix> gcc -shared -fPIC -o libvector.so addvec.c multvec.c
```
`-shared`指示链接器创建一个共享的目标文件
`-fPIC`指示编译器生成与位置无关的代码

###动态链接用处
1. 分发软件，软件更新等
2. 构建高性能web服务器许多web服务器使用fork 和 execve 创建一个子进程。现在可以使用基于动态链接的方法生成动态内容。思路是将生成动态内容的每个函数打包在共享库中，当来自web浏览器的请求到达时，服务器动态的加载和链接适当的函数，然后调用它。

###在应用程序中使用
```C
void *dlopen(const char *filename, int flag);
void *dlsym(void * handle, char *symbol);
int dlclose(void * handle);
```

##处理目标文件的工具
- AR
- NM
- OBJDUMP
- LDD
- READELF
