算法设计与分析基础
=====

#1.绪论
###欧几里得算法
`gcd(m,n) = gcd(n,m mod n)`
```C
int Euclid(int m,int n)
{
	int r=0;
    
	while(n!=0)
    {
    	r=m%n;
        m=n;
        n=r;
    }
    return m;
}
```


###判断素数
埃拉托色尼的筛子
```C
int Sieve1(int n)
{
	int i,j,k;
    bool prime[MAX]={0};
    
    k=sqrt(n);
    for(i=2;i<=k;i++)
    {
    	if(prime[i]==0)
        {
        	for(j=i*i;j<=n;j+=i)
            {
            	prime[j]=1;
            }
        
        }
    }
    j=0;
    for(i=2;i<n+1;i++)
    {
    	if(prime[i]==0)
        	prime_table[j++]=i;
    }
}

int Sieve2(int n)
{
	int i,j,k;
    bool prime[MAX]={0};
    
    k=0;
    for(i=2;i<=n;i++)
    {
    	if(prime[i]==0)
        {
        	prime_table[k++]=i;
        }
        
        for(j=0;j<k && prime_table[j]*i <= n;j++)
        {
        	prime[prime_table[j]*i]=1;
            if(i%prime_table[j]==0)
            	break;
        }
    }
}
```

###算法问题求解基础
1. 理解问题：问题分类
2. 了解计算设备的性能：顺序？并行？存储限制？时间限制？
3. 在精确解法和近视解法做选择
4. 确定适当数据结构
5. 算法设计技术：蛮力法 分治法 减治法 变治法 时空权衡 动态规划 贪婪技术
6. 详细表述算法方法
7. 证明算法正确性
8. 分析算法：时间复杂度，空间复杂度
9. 为算法写代码

###课后题 计算pi
使用Marchin公式
`pi = 16arctg(1/5) - 4arctg(1/239)`
其中`（arctg(x)）‘ = 1/（1+x^2）`
涉及公式如下：
1. 设等比数列`|x|=1`,有
`1/(1-x) = 1 + x + x^2 + x^3 +...x^n...`
2. 泰勒公式
`f(x) = f(a) + (x-1) * f'(a)/1! + (x-a)^2 * f''(a)/2! + .. + (x-a)^n * f'(n)'(a)/n! + R(n)(x)`
3. 泰勒公式的拉格朗日余项
`R(n)(x) = (x-a)^(n+1) * f'(n+1)'(esp)/(n+1)!,  exp~(a,x)`

###重要的问题类型
1. 排序：稳定（冒泡，直接插入，归并，基数），不稳定（选择，快速，希尔，堆排序，）
2. 查找：直接，二分查找，三分查找，哈希表查找
3. 串处理：字符串查找sunday算法
4. 图问题：图遍历，最短路径
5. 组合问题：旅行商，图填色
6. 几何问题：最近点对问题，凸包问题
7. 数值问题

#2.算法效率和分析基础
###基本的效率类型
`1 < logn < n < nlogn < n^2 < n^3 < 2^n < n!`

###谨慎使用递归算法！

###计算斐波那契数列
1. 使用递归 时间复杂度 2^n
2. 使用迭代 时间复杂度 n
3. 使用矩阵 nlogn
 `当n>2时，[F(n-1) F(n) F(n) F(n+1)] = [0 1 1 1]^n`

#3.蛮力法
1. 选择排序，冒泡排序
2. 顺序查找，蛮力字符串匹配
3. 最近对问题，凸包问题
4. 穷举查找

#4.分治法
###合并排序
对于每一个需要排序的数组一分为二，用空间换时间，排序完再合并；
不如直接k路归并排序

###快速排序
快速排序改进：
1. 中轴选取：数组最左边，中间，最右边元素的中值作为中轴
2. 当数组元素较小时，改用更简单的排序
3. 非递归快速排序

```C
void quick_sort(int s[],int left,int right)
{
	int i,j,x;
    while(left<right)
    {
    	i=left;
        j=right;
        x=s[i];
        
        while(i<j)
        {
        	while(i<j && s[j]>=x)
            	j--;
            if(i<j)
            	s[i++]=s[j];
            while(i<j && s[i]<x)
            	i++;
            if(i<j)
            	s[j--]=s[i];
        }
        s[i]=x;
        quick_sort(s,left,i-1);
        quick_sort(s,i+1,right);
    }
}
```

```C
#define MAX_A 100;
#define PUSH(A,B) {
sl[sp]=A;
sr[sp]=B;
sp++;
}
#define POP(A,B) {
A=sl[sp];
B=sr[sp];
sp--;
}

void quick_sort2(int s,int left,int right)
{
	static int sl[MAX_A]={0},sr[MAX_A]={0},sp=0;
    int i,j,x,t;
    
    PUSH(left,right);
    while(sp)
    {
    	POP(left,right);
        i=left;
        j=right;
        x=s[(i+j)/2];
        
        while(i<=j)
        {
        	while(s[j] > x)
            	j--;
            while(s[i] < x)
            	i++;
            if(i<=j)
            {
            	t=s[i];
                s[i]=s[j];
                s[j]=t;
                
                i++;
                j--;
            }
        }
        if(left<j)
        	PUSH(left,j);
        if(i<right);
        	PUSH(i,right);
    }

}
```

###二叉树遍历
先序，中序，后序遍历

###大整数乘法
对任何两位数`a=a1a0`和`b=b1b0`,他们的乘积
`c=a*b=c2*100 + c1*10 + c0`
其中
`c2=a1*b1, c0=a0*b0, c1=(a1+a0)*(b1+b0) -(c0+c2)`

对n位整数a和b，`a=a1*10^(n/2) + a0`,`b=b1*10^(n/2) +b0`,他们的乘积
`c=a*b=(a1+b1)*10^n + (a1*b0 +a0*b1)*10^(n/2) + a0*b0`

###矩阵乘法
略

###最近对问题
画一条竖线x=c，将点集合S分成左右两部分，分别递归的求左右两个子集的最近对，由于可能存在最近对的两端分别在两个子集的情况，所以需要在以x=c为对称的宽度为2d的垂直带中，检查可能符合的点。步骤如下：
1. 根据点的y坐标和x坐标，对S中点排序
2. 找出中线L，将S划分为SL和SR两个子集
3. 将步骤2递归的应用解决SL和SR的最近对问题，并令`d=min{dL,dR}`
4. 将`L-d~L+d`内的点以y值排序，对于每一个点`(x1,y1)`，找出y值在`y1-d,y1+d`内所有的点，计算距离为d'。如果d'小于d，令d=d’，最后的值就是答案。

###凸包问题
快包算法：分治成上包和下包，构造三角形，判断是否在左侧。
如果`p1=(x1,y1),p2=(x2,y2),p3=(x3,y3)`为平面上任意三个点，那么三角形p1p2p3的面积为下列行列式的绝对值的1/2：
|x1 y1 1|
|x2 y2 1| = x1y2 + x2y3 + x3y1 - x3y2 -x2y1 -x1y3
|x3 y3 1|
当且仅当点p3=(x3,y3)位于直线p1p2的左侧时，上式表达式符号为正。使用这个公式可以在固定的时间内，检查一个点是否位于两个点确定的直线的左侧，并且求得这个点到这根直线的最短距离。

还有更好的方法！！待补充～～～


#减治法
1. 减去一个常量
2. 减去一个常因子
3. 减去的规模时可变的

###插入排序
直接插入排序
折半直接插入排序

```C
void insert_sort(int a[],int n)
{
	int i,j,v;
    for(i=1;i<n;i++)
    {
    	v=a[i];
        j=i-1;
        while(j>=0 && a[j]>v)
        {
        	a[j+1]=a[j];
            j--;
        }
        a[j+1]=v;
    }
}
```
希尔排序
待补充～～～

###深度优先查找DFS，广度优先查找BFS
DFS使用栈，在第一次访问一个顶点时，将其压入栈中。
应用：检查图的连通性，无环性
BFS使用队列实现

###拓扑排序
1. 深度优先搜索
2. 基于减一思想，不断的在余下的有向图中求出一个源，他是一个没有输入的顶点，然后把它和所有从他出发的边都删掉，顶点被删除的次序就是一个解。

##生成组合对象的算法
###最小变化生成排列
使用Johnson-Trotter算法
```C
JohnsonTrotter(n)
//输入一个正整数n
//输出{1..n}的所有全排列
将第一个排列初始化为1234...n
while 存在一个移动的整数k do
	求最大的移动整数k
    把k和它箭头指向的相邻整数互换
    调转所有大于k的整数的方向
```
###字典序
```C
一般而言，P是[1...n]的一个全排列，
P = P1P2..Pn = P1P2..P(j-1)PjP(j+1)..P(k-1)PkP(k+1)..Pn
find: j = max{i|Pi < P(i+1)}
	  k = max{i|Pi > Pj}
  1. 对换Pj和Pk
  2. 将P(j+1)..P(k-1)PjP(k+1)...Pn翻转，
  	 P'=P1P2..P(j-1)PkPn..P(k+1)PjP(k-1)...P(j+1)即P的下一个排列
```
```C
int dicsort(int a[],int n)
{
	int i,j,k,t;
    for(i=n-2;i>=0 && a[i]>a[i+1];i--);
    if(i<0)
    	return 1;
    j=i;
    for(i=n-1;i>=0 && a[i]<a[j];i--);
    if(i<0)
    	return 0;
    k=i;
    
    t=a[j];
    a[j]=a[k];
    a[k]=t;
    
    i=j+1;
    k=n-1;
    while(i<k)
    {
    	t=a[i];
        a[i]=a[k];
        a[k]=t;
    }
    
    print(a,n);
    j=dicsort(a,n);
    if(j==0)
    	return 0;
    else
    	return 1;
}
```

###生成子集
挤压序：与之前集合相与获得新的添加部分
最小变化子集：格雷码
算法实现？？？？？？


###俄式乘法
如果n为偶数`n * m = n/2 *2m`,
如果n为奇数`n * m = (n-1)/2 *2m +m`

###约瑟环问题
每个人轮流杀死他旁边的人，求最后剩下的人
～～～～～～～～～～～～`


###第k大元素
1. 基于快速排序思想，分成左右两部分
2. 建堆
```C
int quick_k(int s[],int left,int right,int k)
{
	int i,j,x;
    while(left<right)
    {
    	i=left;
        j=right;
        x=s[i];
        
        while(i<j)
        {
        	while(i<j && s[j]>=x)
            	j--;
            if(i<j)
            	s[i++]=s[j];
            while(i<j && s[i]<x)
            	i++;
            if(i<j)
            	s[j--]=s[i];
        }
        s[i]=x;
        if(right-i = k)
        	return x;
        else if(right-i > k)
	        return quick_k(s,i+1,right,k);
        else 
        	return quick_k(s,left,i-1,k-right+i);
    }
}
```

###插值查找
折半查找：减半下标，比较键值，小数据有效
插值查找：减半键值，比较下标，大数据有效

#变治法
1. 实例化简：预处理
2. 改变表现
3. 问题化简

###高斯消去法
把n个线性方程构成的n元联立方程组，经过初等变化，变换成一个等价的方程组，这个方程组有着一个上三角形的系数矩阵。
初等变换：
1. 交换方程组中两个方程的位置
2. 把一个方程替换为它的非0倍
3. 把一个方程替换为它与另一个方程倍数之间的和或差

优化：每次都找第i 列的系数的绝对值最大行，然后把它作为第i 次迭代的基点。————部分消元法

```C
void BetterGaussElimination(int A[]  [],int b[],int n)
{
	int i,j,k,pos,tmp;
    int B[MAX][MAX]={};
    for(i=0;i<n;i++)
   	{
    	for(j=0;j<n;j++)
        	B[i][j]=A[i][j];
        B[i][j] = b[i];
    }
    
    for(i=0;i<n;i++)
    {
    	pos=i;
        for(j=i+1;j<n;j++)
        	if(abs(B[j][i] > abs(B[pos][i])))
            	pos=j;
        for(k=i;k<n+1;k++)
        {
        	tmp=B[pos][k];
            B[pos][k]=B[i][k];
            B[i][k]=tmp;
        }
        
        for(j=i+1;j<n;j++)
        {
        	tmp=B[j][i]/B[i][i];
            for(k=i;k<n+1;k++)
            	B[j][k] -= B[i][k]*tmp;
        }
    }
    
    for(i=0;i<n;i++)
   	{
    	for(j=0;j<n;j++)
        	A[i][j]=B[i][j];
        b[j] = B[i][j];
    }
}
```

###LU分解
解方程组`Ax=b`等价与解方程组`LUx=b`，设`y=Ux`，那么`Ly=b,Ux=y`次序进行求解即可。对于任意的右边向量b都可求出`Ax=b`的解。
应用：求解矩阵的逆

###计算矩阵行列式
～～～～

###平衡查找树
实现平衡查找树：
1. 实例化简：AVL树要求它的每个节点左右子树高度差不能超过1；红黑树能容忍同一节点的一棵子树的高度是另一棵子树的2倍。
2. 改变表现类型：2-3树，2-3-4树，B树；


###AVL树
平衡因子：左右子树的高度差，只能时0，-1，1中的一个
通过旋转达到平衡：左单旋，右单旋，左右双旋，右左双旋；

###2-3树
允许节点不止包含一个键。
2-3树可以包含两种类型节点的树：2节点树，3节点树。一个2节点树只包含一个键K 和两个子女，左孩子所有键都小于K ，右孩子所有键都大于K ，一个3节点树只包含两个键K1和K2 和三个子女，K1 < K2， 左孩子小于K1 ，中间孩子小于K2 大于K1 ，右孩子大于K2 。
树中所有叶子位于同一层。从根节点到叶子的路径长度是相同的。

###堆
1. 完全二叉树，每层都是满的，除了最后一层最右边元素可能空缺
2. 每个节点的键都要大于等于它子女的键。

使用数组实现堆，从左到右，从上到下的记录堆的元素，留下H[0]，要么让他空着，要么存放限位器，它的值大于堆中任意一个元素。

建堆：
1. 自底向上堆构造
 从最后的父母节点开始，到根为止，该算法检查这些节点的键是否满足父母优势要求。如果该节点不满足，该算法把节点的键K和它的子女的最大键进行交换，然后在检查新的位置上，K是否满足父母优势要求。这一过程一直继续到，对K的父母优势要求满足为止。
```C
void heap_bottom_up(int H[],int n)
{
	int i,j,k,tmp,flag;
    
    for(i=n/2;i>0;i--)
    {
    	k=i;
        tmp=H[k];
        flag=0;
        
        while(!flag && 2*k <= n)
        {
        	j=2*k;
            if(j<n)
            	if(H[j]<H[j+1])
                	j++;
            if(tmp >= H[j])
            	flag=1;
            else
            {
            	H[k]=H[j];
                k=j;
            }
        }
        H[k]=tmp;
    }
}
```
2. 自顶向下构造堆
 把一个新的键K插入到已完成的堆中

根删除或者插入，比较的次数为树的高度`logn`，过时间效率为`O(logn)`

###堆排序
1. 构造堆：为给定的一个数组构造一个堆；
2. 删除最大键：对剩下的堆应用n-1次的根删除操作

堆排序实现～～～～～～～～～～～～～～～～～


###霍纳法则

多项式
`p(x)=2x^4 - x^3 + 3x^2 + x - 5
     =x(x(x(2x-1)+3)+1)-5`

```C
int horner(int a[],int n, int m)
{
	int i,p;
    p=a[n-1];
    for(i=n-2;i>=0;i--)
    	p = m*p + a[i];
     return p;
}
```

综合除法
在计算p(x)在某些点x0上的值时产生的中间数字，恰好可以作为p(x)除以x-x0 的商的系数，而算法的结果，恰好可以作为这个除法的余数。

###二进制冪
计算a^13,这里n=13=(1101)2
1. 从左至右二进制冪:
| n的二进制位 |	1  |		1	   |  	0			|		1			|
|---|
| 累乘器	  |	a	| a^2 * a = a^3 | (a^3) ^2 = a^6 | (a^6) ^2 *a = a^13 |
2. 从右至左二进制冪:
|	1  	  		   | 	1  		   | 0  | 1 | n的二进制位 |
|---|
|	a^8	           |	a^4 	   |a^2	| a |	项	|
| a^5 * a^8 = a^13 | a * a^4 = a^5 |    | a |  累乘器 |

#7.时空权衡
